package blockchainDB

import (
	"crypto/sha512"
	"encoding/binary"
	"fmt"
	"time"
)

const (
	spongeSize = 256            // Must be a power of two
	mask       = spongeSize - 1 // Any power of 2 int less 1 yields a mask
	seedSize   = 512            // Seed in bits
	seedBytes  = seedSize / 8   // Seed in bytes
)

// TODO: Move this into a _test file since it's only used by tests

type FastRandom struct {
	initialSeed []byte
	sponge      [spongeSize]uint64
	seed        [seedBytes]byte
	index       uint64
	state       uint64
}

func (f *FastRandom) Step() {
	f.state ^= f.sponge[f.index&mask]                // fold into the state sponge[index%256]
	f.state ^= f.index                               // Also fold into the state the index
	f.state ^= f.state << 11                         // Do the Xor shift thing
	f.state ^= f.state >> 15                         //
	f.state ^= f.state << 3                          //
	f.sponge[(f.index+spongeSize/2)&mask] ^= f.state // Fold in the state
	f.seed[f.index&(seedBytes-1)] ^= byte(f.state)   // Xor in the f.state
	f.index ^= f.sponge[f.state&mask]                // Avoid the fact that 32 is a factor of 256
}

// Make a clone of a FastRandom state as it currently exists
func (f FastRandom) Clone() *FastRandom {
	f.initialSeed = append([]byte{}, f.initialSeed...)
	return &f
}

// Reset()
// Reset the sequence produced by FastRandom to its initial state
func (f *FastRandom) Reset() {
	// clear the state of the generator:
	for i := range f.sponge {
		f.sponge[i] = 0
	}
	f.seed = [seedBytes]byte{}
	f.index = 0
	f.state = 0

	// then reinitialize it
	f.init(f.initialSeed)
}

// NewFastRandom()
// Returns a Fast Random Generator
// If no seed is provided, the seed will be generated by selecting a random nano second
// In order to make this seed near impossible to guess, we collect nano seconds in a
// loop which means the speed of the CPU and the load on the CPU will create unpredictable
// randomness in the seed.
func NewFastRandom(seed []byte) *FastRandom {
	f := new(FastRandom)
	f.init(seed)
	return f
}

// initFastRandom
// Does the work to initialize the FastRandom generator, and shares it between
// NewFastRandom() and Reset()
func (f *FastRandom) init(seed []byte) {

	if seed == nil { // If no seed is provided, build one from the current time.
		t := time.Now().UnixNano()
		seed = make([]byte, 1024)
		for i := 0; i < 1024; i += 8 {
			go func() { time.Sleep(time.Microsecond) }()
			t = time.Now().UnixNano() ^ t<<15 ^ t>>7
			time.Sleep(time.Microsecond) // Sleep a micro second to make other processes mess
			t = time.Now().UnixNano() ^ t<<13 ^ t>>9
			time.Sleep(time.Microsecond) // Sleep a micro second to make other processes mess
			t = time.Now().UnixNano() ^ t<<17 ^ t>>3
			time.Sleep(time.Microsecond) // Sleep a micro second to make other processes mess
			binary.BigEndian.PutUint64(seed[i%1024:], uint64(t))
		}
	} //                                with the timing

	f.initialSeed = append([]byte{}, seed...) // Copy the initial seed (allow reset)
	f.seed = sha512.Sum512(seed)              // Use the hash of the seed as the seed

	for i := range f.sponge { // Fill the sponge with parts of hashes of hashes
		f.seed = sha512.Sum512(f.seed[:])
		f.sponge[i] = binary.BigEndian.Uint64(f.seed[:])
	}
	for i := 0; i < 512; i++ {
		f.Step()
	}
}

// Uint64
// Return a Uint64
func (f *FastRandom) Uint64() uint64 {
	f.Step()
	return f.state
}

// UintN
// Return an 0 >= int < N
func (f *FastRandom) UintN(N uint) uint {
	f.Step()
	return uint(f.state) % N
}

// NextHahs
// return a random 32 byte array
func (f *FastRandom) NextHash() (hash [32]byte) {
	for i := 0; i < 32; i++ {
		hash[i] = byte(f.state)
		f.Step()
	}
	var a [32]byte
	copy(a[:], f.seed[:32])
	return a
}

func (f *FastRandom) NextBool() bool {
	f.Step()
	return f.state&1 == 1
}

// RandBuff
// Always returns a buffer of random bytes
// If max > 100 MB, max is set to 100 MB
// If max < 1, max is set to 1
// If min > max, min is set to max
func (f *FastRandom) RandBuff(min uint, max uint) []byte {
	if max >= 1024*1024*100 {
		max = 1024 * 1024 * 100
	}
	if max <= 0 {
		max = 1
	}
	if min >= max {
		min = max
	}
	byteCount := max
	if min != max {
		byteCount = f.UintN(max-min) + min
	}
	buff := make([]byte, byteCount)
	count8 := byteCount / 8
	for i := uint(0); i < count8*8; i += 8 {
		binary.BigEndian.PutUint64(buff[i:], f.Uint64())
	}
	for i := count8 * 8; i < byteCount; i++ {
		buff[i] = byte(f.sponge[f.index&15])
	}
	return buff
}

// RandChar
// Returns a buffer of random hex characters
// If max > 100 MB, max is set to 100 MB
// If max < 1, max is set to 1
// If min > max, min is set to max
func (f *FastRandom) RandChar(min uint, max uint) []byte {
	if max <= 0 {
		max = 1
	}
	if min >= max {
		min = max
	}
	byteCount := max
	if min != max {
		byteCount = f.UintN(max-min) + min
	}
	buff := make([]byte, byteCount)
	for i := range buff {
		chr := f.UintN(126-33) + 33
		buff[i] = byte(chr)
	}
	return buff
}

func ComputeTimePerOp(tps float64) string {
	opn := 1 / tps * 1e9 // Operations Per ns
	switch {
	case opn < 1e3:
		return fmt.Sprintf("%4.3f ns", opn)
	case opn < 1e6:
		return fmt.Sprintf("%4.3f us", opn/1e3)
	case opn < 1e9:
		return fmt.Sprintf("%4.3f ms", opn/1e6)
	default:
		return fmt.Sprintf("%4.3f s", opn/1e9)
	}
}
