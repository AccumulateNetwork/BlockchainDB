package blockchainDB

import (
	"crypto/sha256"
	"encoding/binary"
	"time"
)

type FastRandom struct {
	initialSeed []byte
	sponge      [256]uint64
	seed        [32]byte
	index       uint64
	state       uint64
}

func (f *FastRandom) Step() {
	f.state ^= f.sponge[f.index&0xFF]     // fold in the sponge
	f.state ^= f.index                    // fold in the index
	f.state ^= f.state << 11              // Do the Xor shift thing
	f.state ^= f.state >> 15              //
	f.state ^= f.state << 3               //
	f.sponge[f.index&0xFF] ^= f.state     // Fold in the state
	f.seed[f.index&0x1F] ^= byte(f.state) // Xor in the f.state
	f.index ^= f.sponge[f.state&0xFF]     // Avoid the fact that 32 is a factor of 256
}

// Reset()
// Reset the sequence produced by FastRandom to its initial state
func (f *FastRandom) Reset() {
	// clear the state of the generator:
	for i := range f.sponge {
		f.sponge[i] = 0
	}
	f.seed = [32]byte{}
	f.index = 0
	f.state = 0

	// then reinitialize it
	f.init(f.initialSeed)
}

// NewFastRandom()
// Returns a Fast Random Generator
// If no seed is provided, the seed will be generated by selecting a random nano second
// In order to make this seed near impossible to guess, we collect nano seconds in a
// loop which means the speed of the CPU and the load on the CPU will create unpredictable
// randomness in the seed.
func NewFastRandom(seed []byte) *FastRandom {
	f := new(FastRandom)
	f.init(seed)
	return f
}

// initFastRandom
// Does the work to initialize the FastRandom generator, and shares it between
// NewFastRandom() and Reset()
func (f *FastRandom) init(seed []byte) {

	if seed == nil { // If no seed is provided, build one from the current time.
		t := time.Now().UnixNano()
		seed = make([]byte, 1024)
		for i := 0; i < 1024; i += 8 {
			t = time.Now().UnixNano() ^ t<<15 ^ t>>7
			t = time.Now().UnixNano() ^ t<<13 ^ t>>9
			t = time.Now().UnixNano() ^ t<<17 ^ t>>3
			binary.BigEndian.PutUint64(seed[i%1024:], uint64(t))
		}
	}

	f.initialSeed = append([]byte{}, seed...) // Copy the initial seed (allow reset)
	f.seed = sha256.Sum256(seed)              // Use the hash of the seed as the seed

	for i := range f.sponge { // Fill the sponge with parts of hashes of hashes
		f.seed = sha256.Sum256(f.seed[:])
		f.sponge[i] = binary.BigEndian.Uint64(f.seed[:])
	}
	for i := 0; i < 512; i++ {
		f.Step()
	}
}

// Uint64
// Return a Uint64
func (f *FastRandom) Uint64() uint64 {
	f.Step()
	return f.state
}

// UintN
// Return an 0 >= int < N
func (f *FastRandom) UintN(N uint) uint {
	f.Step()
	return uint(f.state) % N
}

// NextHahs
// return a random 32 byte array
func (f *FastRandom) NextHash() (hash [32]byte) {
	for i := 0; i < 32; i++ {
		hash[i] = byte(f.state)
		f.Step()
	}
	var a [32]byte = f.seed
	return a
}

func (f *FastRandom) NextBool() bool {
	f.Step()
	return f.state&1 == 1
}

// RandBuff
// Always returns a buffer of random bytes
// If max > 100 MB, max is set to 100 MB
// If max < 1, max is set to 1
// If min > max, min is set to max
func (f *FastRandom) RandBuff(min uint, max uint) []byte {
	if max >= 1024*1024*100 {
		max = 1024 * 1024 * 100
	}
	if max <= 0 {
		max = 1
	}
	if min >= max {
		min = max
	}
	byteCount := max
	if min != max {
		byteCount = f.UintN(max-min) + min
	}
	buff := make([]byte, byteCount)
	count8 := byteCount / 8
	for i := uint(0); i < count8*8; i += 8 {
		binary.BigEndian.PutUint64(buff[i:], f.Uint64())
	}
	for i := count8 * 8; i < byteCount; i++ {
		buff[i] = byte(f.sponge[f.index&15])
	}
	return buff
}
